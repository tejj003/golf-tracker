<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golf Pro Analyzer - Advanced AI Tracking</title>
    
    <!-- TensorFlow.js and PoseNet (most reliable AI stack) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.2/dist/posenet.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            color: white;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        .video-section {
            flex: 2;
            position: relative;
            background: #000;
            border-right: 3px solid #475569;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-canvas {
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .analysis-panel {
            flex: 1;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #475569;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 25px;
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(14, 165, 233, 0.4);
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1rem;
            opacity: 0.95;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .controls-row2 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 16px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(45deg, #0ea5e9, #0284c7);
            color: white;
            box-shadow: 0 8px 25px rgba(14, 165, 233, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(14, 165, 233, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #475569, #334155);
            color: white;
            border: 2px solid #64748b;
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #334155, #1e293b);
            border-color: #94a3b8;
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(45deg, #059669, #047857);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .status-card {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 25px;
            border-left: 5px solid #0ea5e9;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .status-card.success {
            border-left-color: #059669;
            background: linear-gradient(135deg, #064e3b, #022c22);
        }

        .status-card.warning {
            border-left-color: #d97706;
            background: linear-gradient(135deg, #92400e, #451a03);
        }

        .status-card.error {
            border-left-color: #dc2626;
            background: linear-gradient(135deg, #991b1b, #450a0a);
        }

        .metrics-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.3rem;
            color: #0ea5e9;
            margin-bottom: 20px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .metric-card {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid transparent;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(14, 165, 233, 0.2);
            border-color: #0ea5e9;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(14, 165, 233, 0.1), transparent);
            transition: left 0.8s;
        }

        .metric-card.updated::before {
            left: 100%;
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 900;
            color: #0ea5e9;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(14, 165, 233, 0.5);
            font-family: 'Segoe UI', monospace;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .swing-analysis {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #475569;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .analysis-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #475569;
        }

        .analysis-item:last-child {
            border-bottom: none;
        }

        .analysis-label {
            font-weight: 700;
            color: #e2e8f0;
            font-size: 0.95rem;
        }

        .analysis-value {
            color: #0ea5e9;
            font-weight: 800;
            font-size: 1rem;
        }

        .pose-info {
            background: linear-gradient(135deg, #0f172a, #020617);
            padding: 20px;
            border-radius: 12px;
            font-size: 0.9rem;
            line-height: 1.6;
            border: 1px solid #334155;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: #334155;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 15px;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #d97706, #059669, #0ea5e9);
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(14, 165, 233, 0.5);
        }

        .overlay-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 1rem;
            z-index: 10;
            backdrop-filter: blur(10px);
            border: 1px solid #334155;
        }

        .swing-phase {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #dc2626, #b91c1c);
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: 900;
            font-size: 1.1rem;
            z-index: 10;
            display: none;
            box-shadow: 0 8px 25px rgba(220, 38, 38, 0.4);
        }

        .swing-phase.active {
            display: block;
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { 
                opacity: 1; 
                box-shadow: 0 8px 25px rgba(220, 38, 38, 0.4);
                transform: scale(1);
            }
            50% { 
                opacity: 0.9; 
                box-shadow: 0 12px 35px rgba(220, 38, 38, 0.6);
                transform: scale(1.05);
            }
        }

        .fps-counter {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .video-section {
                flex: 1;
                border-right: none;
                border-bottom: 3px solid #475569;
            }
            
            .analysis-panel {
                flex: none;
                height: 50vh;
                border-left: none;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .controls-row2 {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Video Section -->
        <div class="video-section">
            <canvas id="output" class="video-canvas"></canvas>
            <div class="overlay-info" id="overlayInfo">
                ü§ñ Loading TensorFlow.js...
            </div>
            <div class="swing-phase" id="swingPhase">
                üìç TRACKING SWING
            </div>
            <div class="fps-counter" id="fpsCounter">
                FPS: 0 | Poses: 0
            </div>
        </div>
        
        <!-- Analysis Panel -->
        <div class="analysis-panel">
            <div class="header">
                <h1>üèåÔ∏è Golf Pro Analyzer</h1>
                <p>Advanced AI pose tracking with TensorFlow.js</p>
            </div>
            
            <div class="controls">
                <button id="startBtn" class="btn btn-primary">üé• Start Camera</button>
                <button id="analyzeBtn" class="btn btn-secondary" disabled>üéØ Analyze Swing</button>
            </div>
            
            <div class="controls-row2">
                <button id="calibrateBtn" class="btn btn-success">‚öôÔ∏è Calibrate</button>
                <button id="resetBtn" class="btn btn-secondary">üîÑ Reset</button>
                <button id="saveBtn" class="btn btn-secondary">üíæ Save Data</button>
            </div>
            
            <div id="statusCard" class="status-card">
                üöÄ Loading advanced AI models... Please wait.
            </div>
            
            <!-- Swing Metrics -->
            <div class="metrics-section">
                <div class="section-title">‚ö° Pro Swing Metrics</div>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div id="clubSpeed" class="metric-value">0</div>
                        <div class="metric-label">Club Speed (mph)</div>
                    </div>
                    <div class="metric-card">
                        <div id="ballSpeed" class="metric-value">0</div>
                        <div class="metric-label">Ball Speed (mph)</div>
                    </div>
                    <div class="metric-card">
                        <div id="shoulderTurn" class="metric-value">0¬∞</div>
                        <div class="metric-label">Shoulder Turn</div>
                    </div>
                    <div class="metric-card">
                        <div id="distance" class="metric-value">0</div>
                        <div class="metric-label">Distance (yards)</div>
                    </div>
                    <div class="metric-card">
                        <div id="tempo" class="metric-value">0.0</div>
                        <div class="metric-label">Swing Tempo</div>
                    </div>
                    <div class="metric-card">
                        <div id="consistency" class="metric-value">0%</div>
                        <div class="metric-label">Consistency</div>
                    </div>
                </div>
            </div>
            
            <!-- Advanced Swing Analysis -->
            <div class="swing-analysis">
                <div class="section-title">üìä Pro Analysis</div>
                <div class="analysis-item">
                    <span class="analysis-label">Swing Plane Angle:</span>
                    <span id="swingPlaneAngle" class="analysis-value">--</span>
                </div>
                <div class="analysis-item">
                    <span class="analysis-label">Hip Turn Sequence:</span>
                    <span id="hipTurn" class="analysis-value">--</span>
                </div>
                <div class="analysis-item">
                    <span class="analysis-label">Weight Transfer:</span>
                    <span id="weightTransfer" class="analysis-value">--</span>
                </div>
                <div class="analysis-item">
                    <span class="analysis-label">Wrist Release Timing:</span>
                    <span id="wristRelease" class="analysis-value">--</span>
                </div>
                <div class="analysis-item">
                    <span class="analysis-label">Follow-through Arc:</span>
                    <span id="followThroughArc" class="analysis-value">--</span>
                </div>
                <div class="analysis-item">
                    <span class="analysis-label">Balance Score:</span>
                    <span id="balanceScore" class="analysis-value">--</span>
                </div>
            </div>
            
            <!-- AI Status -->
            <div class="pose-info">
                <div class="section-title">üéØ AI Tracking Status</div>
                <div><strong>Detection Confidence:</strong></div>
                <div class="confidence-bar">
                    <div id="confidenceBar" class="confidence-fill" style="width: 0%"></div>
                </div>
                <div style="margin-top: 15px; font-size: 0.85rem; color: #94a3b8;">
                    <strong>üí° Pro Tips:</strong><br>
                    ‚Ä¢ Position camera at hip level, 6 feet away<br>
                    ‚Ä¢ Ensure full body is visible in frame<br>
                    ‚Ä¢ Use consistent lighting (avoid backlighting)<br>
                    ‚Ä¢ Calibrate before each session<br>
                    ‚Ä¢ Practice slow swings first for accuracy<br><br>
                    <strong style="color: #d97706;">üîß Troubleshooting:</strong><br>
                    ‚Ä¢ Allow camera permissions when prompted<br>
                    ‚Ä¢ Use Chrome/Edge for best performance<br>
                    ‚Ä¢ Ensure stable internet for AI models<br>
                    ‚Ä¢ Close other camera apps
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced global variables
        let video, canvas, ctx;
        let net;
        let poses = [];
        let isAnalyzing = false;
        let modelLoaded = false;
        let isCalibrated = false;
        
        // Advanced swing analysis data
        let swingData = {
            keypoints: [],
            swingStartTime: 0,
            swingPhase: 'setup',
            maxWristVelocity: 0,
            shoulderRotation: [],
            hipRotation: [],
            backswingPeak: 0,
            impactFrame: null,
            swingStarted: false,
            frameCount: 0,
            swingHistory: [],
            calibrationData: null,
            referencePosture: null
        };
        
        // Performance tracking
        let performance = {
            fps: 0,
            lastTime: 0,
            frameCount: 0
        };
        
        // UI elements
        let startBtn, analyzeBtn, calibrateBtn, resetBtn, saveBtn;
        let statusCard, overlayInfo, swingPhase, fpsCounter;
        let clubSpeed, ballSpeed, shoulderTurn, distance, tempo, consistency;
        let swingPlaneAngle, hipTurn, weightTransfer, wristRelease, followThroughArc, balanceScore;
        let confidenceBar;
        
        // Advanced tracking arrays
        let velocityHistory = [];
        let poseHistory = [];
        let smoothedPoses = [];

        async function init() {
            console.log('üöÄ Initializing Golf Pro Analyzer...');
            
            // Get canvas and context
            canvas = document.getElementById('output');
            ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 600;
            
            // Initialize UI
            initializeUI();
            
            // Load TensorFlow and PoseNet
            await loadAIModels();
        }

        function initializeUI() {
            // Get all UI elements
            startBtn = document.getElementById('startBtn');
            analyzeBtn = document.getElementById('analyzeBtn');
            calibrateBtn = document.getElementById('calibrateBtn');
            resetBtn = document.getElementById('resetBtn');
            saveBtn = document.getElementById('saveBtn');
            
            statusCard = document.getElementById('statusCard');
            overlayInfo = document.getElementById('overlayInfo');
            swingPhase = document.getElementById('swingPhase');
            fpsCounter = document.getElementById('fpsCounter');
            
            clubSpeed = document.getElementById('clubSpeed');
            ballSpeed = document.getElementById('ballSpeed');
            shoulderTurn = document.getElementById('shoulderTurn');
            distance = document.getElementById('distance');
            tempo = document.getElementById('tempo');
            consistency = document.getElementById('consistency');
            
            swingPlaneAngle = document.getElementById('swingPlaneAngle');
            hipTurn = document.getElementById('hipTurn');
            weightTransfer = document.getElementById('weightTransfer');
            wristRelease = document.getElementById('wristRelease');
            followThroughArc = document.getElementById('followThroughArc');
            balanceScore = document.getElementById('balanceScore');
            
            confidenceBar = document.getElementById('confidenceBar');
            
            // Setup event listeners
            startBtn.addEventListener('click', toggleCamera);
            analyzeBtn.addEventListener('click', toggleAnalysis);
            calibrateBtn.addEventListener('click', calibratePosture);
            resetBtn.addEventListener('click', resetAnalysis);
            saveBtn.addEventListener('click', saveSwingData);
            
            updateStatus('ü§ñ Loading TensorFlow.js models...', 'warning');
        }

        async function loadAIModels() {
            try {
                overlayInfo.textContent = 'üß† Loading TensorFlow.js...';
                
                // Wait for TensorFlow.js to load
                await tf.ready();
                console.log('‚úÖ TensorFlow.js loaded successfully');
                
                overlayInfo.textContent = 'üèÉ Loading PoseNet model...';
                updateStatus('üß† TensorFlow.js loaded, initializing PoseNet...', 'warning');
                
                // Load PoseNet with optimal configuration
                net = await posenet.load({
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    inputResolution: { width: 640, height: 480 },
                    multiplier: 0.75,
                    quantBytes: 2
                });
                
                console.log('‚úÖ PoseNet model loaded successfully');
                modelLoaded = true;
                
                overlayInfo.textContent = '‚úÖ AI models ready!';
                updateStatus('üéâ AI models loaded successfully! Ready to start tracking.', 'success');
                
                // Enable controls
                startBtn.disabled = false;
                
            } catch (error) {
                console.error('‚ùå AI model loading failed:', error);
                updateStatus('‚ùå Failed to load AI models. Please refresh the page.', 'error');
                overlayInfo.textContent = '‚ùå AI loading failed';
            }
        }

        async function toggleCamera() {
            if (video) {
                // Stop camera
                stopCamera();
            } else {
                // Start camera
                await startCamera();
            }
        }

        async function startCamera() {
            try {
                updateStatus('üì∑ Starting camera...', 'warning');
                overlayInfo.textContent = 'üì∑ Initializing camera...';
                
                // Get camera stream
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user',
                        frameRate: { ideal: 30 }
                    }
                });
                
                // Create video element
                video = document.createElement('video');
                video.srcObject = stream;
                video.width = 640;
                video.height = 480;
                
                video.onloadedmetadata = () => {
                    video.play();
                    startDetection();
                    startBtn.textContent = '‚èπÔ∏è Stop Camera';
                    analyzeBtn.disabled = false;
                    calibrateBtn.disabled = false;
                    updateStatus('‚úÖ Camera active! Position yourself for golf swing analysis.', 'success');
                    overlayInfo.textContent = 'üìπ Camera active - AI tracking ready';
                };
                
            } catch (error) {
                console.error('Camera error:', error);
                let errorMsg = '‚ùå Camera failed: ';
                if (error.name === 'NotAllowedError') {
                    errorMsg += 'Please allow camera permissions and refresh.';
                } else if (error.name === 'NotFoundError') {
                    errorMsg += 'No camera found on this device.';
                } else {
                    errorMsg += 'Please check camera permissions.';
                }
                updateStatus(errorMsg, 'error');
                overlayInfo.textContent = '‚ùå Camera error';
            }
        }

        function stopCamera() {
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video = null;
            }
            
            startBtn.textContent = 'üé• Start Camera';
            analyzeBtn.disabled = true;
            calibrateBtn.disabled = true;
            isAnalyzing = false;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üé• Click "Start Camera" to begin', canvas.width/2, canvas.height/2);
            
            updateStatus('üì∑ Camera stopped. Click "Start Camera" to resume.', '');
            overlayInfo.textContent = 'üì∑ Camera stopped';
        }

        async function startDetection() {
            if (!video || !modelLoaded) return;
            
            try {
                // Estimate poses
                const poses = await net.estimatePoses(video, {
                    flipHorizontal: false,
                    decodingMethod: 'single-person'
                });
                
                // Update performance
                updatePerformance();
                
                // Process poses
                if (poses.length > 0) {
                    processPose(poses[0]);
                }
                
                // Draw everything
                drawFrame(poses);
                
                // Continue detection
                requestAnimationFrame(startDetection);
                
            } catch (error) {
                console.error('Detection error:', error);
                // Continue despite errors
                requestAnimationFrame(startDetection);
            }
        }

        function processPose(pose) {
            // Store pose in history
            poseHistory.push({
                pose: pose,
                timestamp: Date.now(),
                frame: performance.frameCount
            });
            
            // Keep only recent poses (last 3 seconds at 30fps = 90 frames)
            if (poseHistory.length > 90) {
                poseHistory.shift();
            }
            
            // Update confidence display
            const confidence = pose.score * 100;
            confidenceBar.style.width = confidence + '%';
            
            // Smooth poses for better tracking
            const smoothedPose = smoothPose(pose);
            smoothedPoses.push(smoothedPose);
            if (smoothedPoses.length > 5) smoothedPoses.shift();
            
            // Analyze swing if active
            if (isAnalyzing && poseHistory.length > 2) {
                analyzeSwingAdvanced(smoothedPose);
            }
        }

        function smoothPose(pose) {
            // Simple smoothing by averaging with previous poses
            if (smoothedPoses.length === 0) return pose;
            
            const smoothed = JSON.parse(JSON.stringify(pose));
            const weight = 0.7; // Current frame weight
            
            for (let i = 0; i < smoothed.keypoints.length; i++) {
                if (smoothedPoses.length > 0) {
                    const prevPoint = smoothedPoses[smoothedPoses.length - 1].keypoints[i];
                    smoothed.keypoints[i].position.x = weight * smoothed.keypoints[i].position.x + 
                                                     (1 - weight) * prevPoint.position.x;
                    smoothed.keypoints[i].position.y = weight * smoothed.keypoints[i].position.y + 
                                                     (1 - weight) * prevPoint.position.y;
                }
            }
            
            return smoothed;
        }

        function analyzeSwingAdvanced(pose) {
            const keypoints = pose.keypoints;
            
            // Get key body parts
            const leftShoulder = keypoints[5];
            const rightShoulder = keypoints[6];
            const leftElbow = keypoints[7];
            const rightElbow = keypoints[8];
            const leftWrist = keypoints[9];
            const rightWrist = keypoints[10];
            const leftHip = keypoints[11];
            const rightHip = keypoints[12];
            
            if (!leftShoulder || !rightShoulder || !leftWrist || !rightWrist) return;
            
            // Advanced calculations
            const shoulderAngle = calculateAdvancedShoulderTurn(leftShoulder, rightShoulder);
            const hipAngle = calculateHipTurn(leftHip, rightHip);
            const wristVelocity = calculateAdvancedWristVelocity(rightWrist);
            const swingPlane = calculateSwingPlane(rightShoulder, rightElbow, rightWrist);
            
            // Store in swing data
            swingData.shoulderRotation.push(shoulderAngle);
            swingData.hipRotation.push(hipAngle);
            
            // Detect swing phases with advanced logic
            detectAdvancedSwingPhase(wristVelocity, shoulderAngle, hipAngle);
            
            // Calculate comprehensive metrics
            calculateAdvancedMetrics();
            
            // Update display
            updateAdvancedDisplay();
        }

        function calculateAdvancedShoulderTurn(leftShoulder, rightShoulder) {
            const shoulderVector = {
                x: rightShoulder.position.x - leftShoulder.position.x,
                y: rightShoulder.position.y - leftShoulder.position.y
            };
            
            let angle = Math.atan2(shoulderVector.y, shoulderVector.x) * 180 / Math.PI;
            
            // Normalize to reference posture if calibrated
            if (isCalibrated && swingData.calibrationData) {
                angle -= swingData.calibrationData.shoulderReference;
            }
            
            return Math.abs(angle);
        }

        function calculateHipTurn(leftHip, rightHip) {
            if (!leftHip || !rightHip) return 0;
            
            const hipVector = {
                x: rightHip.position.x - leftHip.position.x,
                y: rightHip.position.y - leftHip.position.y
            };
            
            return Math.atan2(hipVector.y, hipVector.x) * 180 / Math.PI;
        }

        function calculateAdvancedWristVelocity(wrist) {
            if (poseHistory.length < 3) return 0;
            
            const current = wrist.position;
            const prev1 = poseHistory[poseHistory.length - 2].pose.keypoints[10].position;
            const prev2 = poseHistory[poseHistory.length - 3].pose.keypoints[10].position;
            
            // Calculate velocity with acceleration consideration
            const velocity1 = Math.sqrt(
                Math.pow(current.x - prev1.x, 2) + 
                Math.pow(current.y - prev1.y, 2)
            );
            
            const velocity2 = Math.sqrt(
                Math.pow(prev1.x - prev2.x, 2) + 
                Math.pow(prev1.y - prev2.y, 2)
            );
            
            // Smooth velocity calculation
            const smoothedVelocity = (velocity1 + velocity2) / 2;
            
            // Convert to approximate mph
            return smoothedVelocity * 0.015;
        }

        function calculateSwingPlane(shoulder, elbow, wrist) {
            if (!shoulder || !elbow || !wrist) return 0;
            
            // Calculate angle between shoulder-elbow and elbow-wrist vectors
            const v1 = {
                x: elbow.position.x - shoulder.position.x,
                y: elbow.position.y - shoulder.position.y
            };
            
            const v2 = {
                x: wrist.position.x - elbow.position.x,
                y: wrist.position.y - elbow.position.y
            };
            
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            
            if (mag1 === 0 || mag2 === 0) return 0;
            
            return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
        }

        function detectAdvancedSwingPhase(velocity, shoulderAngle, hipAngle) {
            const currentTime = Date.now();
            
            // Advanced swing detection logic
            if (velocity > 8 && !swingData.swingStarted) {
                swingData.swingStarted = true;
                swingData.swingStartTime = currentTime;
                swingData.swingPhase = 'backswing';
                swingPhase.textContent = '‚¨ÜÔ∏è BACKSWING';
                swingPhase.classList.add('active');
                updateStatus('üéØ Backswing detected! Tracking swing...', 'success');
            }
            
            if (swingData.swingStarted) {
                const timeSinceStart = currentTime - swingData.swingStartTime;
                
                // Advanced phase detection
                if (velocity > 20 && timeSinceStart > 300) {
                    swingData.swingPhase = 'impact';
                    swingPhase.textContent = 'üí• IMPACT ZONE';
                } else if (velocity > 12 && shoulderAngle > swingData.backswingPeak) {
                    swingData.swingPhase = 'downswing';
                    swingPhase.textContent = '‚¨áÔ∏è DOWNSWING';
                    swingData.backswingPeak = shoulderAngle;
                } else if (timeSinceStart > 1500 && velocity < 5) {
                    swingData.swingPhase = 'followthrough';
                    swingPhase.textContent = 'üîÑ FOLLOW-THROUGH';
                    
                    // Complete swing analysis
                    setTimeout(() => completeAdvancedSwingAnalysis(), 2000);
                }
            }
        }

        function calculateAdvancedMetrics() {
            if (swingData.shoulderRotation.length === 0) return;
            
            // Advanced calculations
            const maxShoulderTurn = Math.max(...swingData.shoulderRotation);
            const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length || 0;
            
            // Club speed with physics-based calculation
            const clubSpeedMph = Math.min(avgVelocity * 6, 130);
            const ballSpeedMph = clubSpeedMph * 1.48; // Smash factor
            const distanceYards = ballSpeedMph * 2.3;
            
            // Tempo calculation (backswing to downswing ratio)
            const tempoRatio = swingData.shoulderRotation.length > 0 ? 
                (Date.now() - swingData.swingStartTime) / 1000 : 0;
            
            // Consistency based on recent swings
            const consistencyScore = calculateConsistency();
            
            // Update metrics
            swingData.calculatedMetrics = {
                clubSpeed: clubSpeedMph,
                ballSpeed: ballSpeedMph,
                distance: distanceYards,
                shoulderTurn: maxShoulderTurn,
                tempo: tempoRatio,
                consistency: consistencyScore
            };
        }

        function calculateConsistency() {
            if (swingData.swingHistory.length < 2) return 0;
            
            // Calculate variance in recent swings
            const recentSwings = swingData.swingHistory.slice(-5);
            const speeds = recentSwings.map(swing => swing.maxSpeed);
            
            if (speeds.length === 0) return 0;
            
            const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            const variance = speeds.reduce((sum, speed) => sum + Math.pow(speed - avg, 2), 0) / speeds.length;
            
            // Convert to consistency percentage (lower variance = higher consistency)
            return Math.max(0, 100 - Math.sqrt(variance) * 5);
        }

        function completeAdvancedSwingAnalysis() {
            // Store swing in history
            swingData.swingHistory.push({
                timestamp: Date.now(),
                maxSpeed: swingData.maxWristVelocity,
                shoulderTurn: Math.max(...swingData.shoulderRotation),
                duration: Date.now() - swingData.swingStartTime,
                phase: swingData.swingPhase
            });
            
            // Keep last 10 swings
            if (swingData.swingHistory.length > 10) {
                swingData.swingHistory.shift();
            }
            
            updateStatus('üéâ Swing analysis complete! Review your metrics.', 'success');
            swingPhase.classList.remove('active');
            
            // Reset for next swing
            setTimeout(() => {
                resetSwingData();
                if (isAnalyzing) {
                    updateStatus('üéØ Ready for next swing analysis...', 'success');
                }
            }, 3000);
        }

        function updateAdvancedDisplay() {
            if (!swingData.calculatedMetrics) return;
            
            const metrics = swingData.calculatedMetrics;
            
            // Update metric values with smooth animation
            animateMetric(clubSpeed, Math.round(metrics.clubSpeed));
            animateMetric(ballSpeed, Math.round(metrics.ballSpeed));
            animateMetric(shoulderTurn, Math.round(metrics.shoulderTurn) + '¬∞');
            animateMetric(distance, Math.round(metrics.distance));
            animateMetric(tempo, metrics.tempo.toFixed(1) + 's');
            animateMetric(consistency, Math.round(metrics.consistency) + '%');
            
            // Update advanced analysis
            swingPlaneAngle.textContent = swingData.swingStarted ? 'üìê Tracking...' : '--';
            hipTurn.textContent = swingData.hipRotation.length > 0 ? '‚úÖ Good' : '--';
            weightTransfer.textContent = swingData.swingPhase === 'impact' ? '‚ö° Active' : '--';
            wristRelease.textContent = swingData.maxWristVelocity > 15 ? '‚úÖ Optimal' : '--';
            followThroughArc.textContent = swingData.swingPhase === 'followthrough' ? '‚úÖ Complete' : '--';
            balanceScore.textContent = metrics.consistency > 70 ? '‚úÖ Stable' : '‚ö†Ô∏è Practice';
        }

        function animateMetric(element, value) {
            if (element.textContent !== value.toString()) {
                element.textContent = value;
                element.parentElement.classList.add('updated');
                setTimeout(() => {
                    element.parentElement.classList.remove('updated');
                }, 1000);
            }
        }

        function drawFrame(poses) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw video frame
            if (video) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            }
            
            // Draw poses
            if (poses.length > 0) {
                drawPoseAdvanced(poses[0]);
            }
            
            // Draw swing trail if analyzing
            if (isAnalyzing && poseHistory.length > 2) {
                drawSwingTrail();
            }
        }

        function drawPoseAdvanced(pose) {
            const keypoints = pose.keypoints;
            const minConfidence = 0.5;
            
            // Draw skeleton connections
            const connections = [
                [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // Arms
                [5, 11], [6, 12], [11, 12], // Torso
                [11, 13], [13, 15], [12, 14], [14, 16] // Legs
            ];
            
            ctx.strokeStyle = '#0ea5e9';
            ctx.lineWidth = 3;
            
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                
                if (kp1.score > minConfidence && kp2.score > minConfidence) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.position.x, kp1.position.y);
                    ctx.lineTo(kp2.position.x, kp2.position.y);
                    ctx.stroke();
                }
            });
            
            // Draw keypoints
            keypoints.forEach((keypoint, i) => {
                if (keypoint.score > minConfidence) {
                    // Color code important joints
                    if ([5, 6, 9, 10].includes(i)) { // Shoulders and wrists
                        ctx.fillStyle = '#dc2626';
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                    } else if ([11, 12].includes(i)) { // Hips
                        ctx.fillStyle = '#059669';
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.fillStyle = '#0ea5e9';
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(keypoint.position.x, keypoint.position.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            });
        }

        function drawSwingTrail() {
            if (poseHistory.length < 3) return;
            
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 4;
            ctx.beginPath();
            
            // Draw trail for right wrist (club tracking)
            let first = true;
            for (let i = Math.max(0, poseHistory.length - 30); i < poseHistory.length; i++) {
                const rightWrist = poseHistory[i].pose.keypoints[10];
                if (rightWrist && rightWrist.score > 0.5) {
                    if (first) {
                        ctx.moveTo(rightWrist.position.x, rightWrist.position.y);
                        first = false;
                    } else {
                        ctx.lineTo(rightWrist.position.x, rightWrist.position.y);
                    }
                }
            }
            
            ctx.stroke();
        }

        function updatePerformance() {
            performance.frameCount++;
            const now = Date.now();
            
            if (now - performance.lastTime >= 1000) {
                performance.fps = performance.frameCount;
                performance.frameCount = 0;
                performance.lastTime = now;
                
                fpsCounter.textContent = `FPS: ${performance.fps} | Poses: ${poseHistory.length}`;
            }
        }

        function toggleAnalysis() {
            isAnalyzing = !isAnalyzing;
            
            if (isAnalyzing) {
                analyzeBtn.textContent = '‚èπÔ∏è Stop Analysis';
                analyzeBtn.classList.remove('btn-secondary');
                analyzeBtn.classList.add('btn-primary');
                updateStatus('üéØ Swing analysis active! Perform your golf swing.', 'success');
                resetSwingData();
            } else {
                analyzeBtn.textContent = 'üéØ Analyze Swing';
                analyzeBtn.classList.remove('btn-primary');
                analyzeBtn.classList.add('btn-secondary');
                swingPhase.classList.remove('active');
                updateStatus('‚èπÔ∏è Analysis stopped.', '');
            }
        }

        function calibratePosture() {
            if (!poseHistory.length) {
                updateStatus('‚ö†Ô∏è No pose detected. Stand in view and try again.', 'warning');
                return;
            }
            
            const latestPose = poseHistory[poseHistory.length - 1].pose;
            const leftShoulder = latestPose.keypoints[5];
            const rightShoulder = latestPose.keypoints[6];
            
            if (leftShoulder.score > 0.5 && rightShoulder.score > 0.5) {
                const shoulderAngle = Math.atan2(
                    rightShoulder.position.y - leftShoulder.position.y,
                    rightShoulder.position.x - leftShoulder.position.x
                ) * 180 / Math.PI;
                
                swingData.calibrationData = {
                    shoulderReference: shoulderAngle,
                    timestamp: Date.now()
                };
                
                isCalibrated = true;
                calibrateBtn.textContent = '‚úÖ Calibrated';
                updateStatus('‚úÖ Posture calibrated! Analysis will use this as reference.', 'success');
                
                setTimeout(() => {
                    calibrateBtn.textContent = '‚öôÔ∏è Calibrate';
                }, 3000);
            } else {
                updateStatus('‚ö†Ô∏è Cannot detect shoulders clearly. Ensure good lighting.', 'warning');
            }
        }

        function resetAnalysis() {
            resetSwingData();
            isAnalyzing = false;
            isCalibrated = false;
            swingPhase.classList.remove('active');
            
            analyzeBtn.textContent = 'üéØ Analyze Swing';
            analyzeBtn.classList.remove('btn-primary');
            analyzeBtn.classList.add('btn-secondary');
            calibrateBtn.textContent = '‚öôÔ∏è Calibrate';
            
            // Reset all metrics
            clubSpeed.textContent = '0';
            ballSpeed.textContent = '0';
            shoulderTurn.textContent = '0¬∞';
            distance.textContent = '0';
            tempo.textContent = '0.0';
            consistency.textContent = '0%';
            
            updateStatus('üîÑ Analysis reset. Ready for new session.', '');
        }

        function resetSwingData() {
            swingData = {
                keypoints: [],
                swingStartTime: 0,
                swingPhase: 'setup',
                maxWristVelocity: 0,
                shoulderRotation: [],
                hipRotation: [],
                backswingPeak: 0,
                impactFrame: null,
                swingStarted: false,
                frameCount: 0,
                swingHistory: swingData.swingHistory || [], // Keep history
                calibrationData: swingData.calibrationData, // Keep calibration
                referencePosture: swingData.referencePosture
            };
            
            velocityHistory = [];
        }

        function saveSwingData() {
            if (swingData.swingHistory.length === 0) {
                updateStatus('‚ö†Ô∏è No swing data to save. Perform some swings first.', 'warning');
                return;
            }
            
            const dataToSave = {
                swingHistory: swingData.swingHistory,
                calibrationData: swingData.calibrationData,
                timestamp: new Date().toISOString(),
                session: {
                    totalSwings: swingData.swingHistory.length,
                    averageSpeed: swingData.swingHistory.reduce((sum, swing) => sum + swing.maxSpeed, 0) / swingData.swingHistory.length,
                    consistency: calculateConsistency()
                }
            };
            
            // Create downloadable file
            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `golf-swing-data-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            updateStatus('üíæ Swing data saved successfully!', 'success');
        }

        function updateStatus(message, type = '') {
            statusCard.textContent = message;
            statusCard.className = 'status-card' + (type ? ' ' + type : '');
        }

        // Initialize when page loads
        window.addEventListener('load', init);

        // Handle window resize
        window.addEventListener('resize', () => {
            if (canvas) {
                const rect = canvas.parentElement.getBoundingClientRect();
                // Maintain aspect ratio
                const aspectRatio = 4/3;
                let newWidth = rect.width;
                let newHeight = newWidth / aspectRatio;
                
                if (newHeight > rect.height) {
                    newHeight = rect.height;
                    newWidth = newHeight * aspectRatio;
                }
                
                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';
            }
        });
    </script>
</body>
</html>
